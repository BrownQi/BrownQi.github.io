{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Downloads","text":"相关内容下载链接 oracle相关oracle11g官方文档中英对照版提取码：vb3a oracle11g_x64 提取码：uyf6","link":"/2019/10/09/Downloads/"},{"title":"Socket","text":"概述应用编程接口APIApplication Programming Interface 定义：API就是应用进程的控制权和操作系统的控制权进行转换的一个系统调用接口。 几种典型的应用编程接口 Berkeley UNIX 操作系统定义了一种AOI，称为套接字接口（socket interface），简称套接字（socket）。 微软公司在其操作系统中采用了套接字接口API，形成了一个稍有不同的API，并称之为Windows Socket Interface，简称WINSOCK。 AT&amp;T为其UNIX系统V定义了一种API，简写为TLI（Transport Layer Interface）。 Socket API 最初设计 面向BSD UNIX-Berkley 面向TCP/IP协议栈接口 目前 事实上的工业标准 绝大多数操作系统都支持 Internet网络应用最典型的API接口 通信模型 客服/服务器（C/S） 应用进程间通信的抽象机制 表示通信端点（对外）： IP地址 + 端口号 操作系统/进程如何管理套接字（对内）： 套接字描述符 （socket） 小整数 Socket抽象 类似于文件的抽象 当应用进程创建套接字时，操作系统分配一个数据结构存储该套接字相关信息 返回套接字描述符 地址结构 已定义结构sockaddr_in: 12345678sturct sockaddr_in{ u_char sin_len; /*地址长度*/ u_char sin_family; /*地址组（TCP/IP:AF_INET）*/ u_short sin_port; /*端口号*/ struct in_addr sin_addr; /*IP地址*/ char sin_zero[8]; /*未用（置0）*/} 使用TCP/IP协议簇的网络应用程序声明端点地址变量时，使用结构sockaddr_in Socket API函数（WinSock）123graph TB A[WSAStartup&lt;br&gt;初始化Windows Sockets AP] --&gt; B[应用程序] B --&gt; C[WSACleanup&lt;BR&gt;释放所使用的Windows Sockets DLL] WSAStartup1int WSAStartup(WORD wVersionRequested,LPWSADATA IpWSAData); 使用Socket的应用程序在使用Socket之前必须首先 调用WSAStartup函数 两个参数： 第一个参数指明程序请求使用的WinSock版本，其中高位字节指明副版本，低位字节指明主版本。 十六进制整数，例如0x102表示2.1版 第二个参数返回实际的WinSock的版本信息 指向WSADATA结构的指针 例：使用2.1版本的WinSock的程序代码段 12wVersionRequested = MAKEWORD(2,1);err = WSAStartup( wVersionRequested, &amp;wsaData ); WSACleanup1int WSACleanup (void); 应用程序在完成对请求的Socket库的使用，最后要调用WSACleanup函数 解除与Socket库的绑定 释放Socket库所占用的系统资源 socket1sd = socket(protofamily,type,proto); 创建套接字 操作系统返回套接字描述符（sd） 第一个参数（协议族）：protofamily = PF_INET (TCP/TP)","link":"/2019/10/10/Socket/"},{"title":"使用hexo搭建个人博客","text":"使用hexo框架搭在windows平台建个人博客，并部署到github。 1. 安装node.js1.1 下载地址node.js 1.2 确认是否安装成功终端下 1node -v 1npm -v 1.3 利用npm安装cnpm(利用淘宝源)1npm install -g cnpm --registry=https://registry.npm.taobao.org 2. 安装hexo1cnpm install -g hexo-cli 3. 配置个人博客3.1 创建本地博客目录1mkdir blog 3.2 初始化hexo个人博客1hexo init 4. hexo常用命令4.1 创建新的文章1hexo n &quot;newBlog&quot; 4.2 生成博客1hexo g 4.3启动博客（本地预览）1hexo s 127.0.0.1:4000 4.4 部署到远端（使用git）1hexo d 5. 部署到github5.1 安装git bashgit bash 下载链接 配置 git 账户、邮箱 123git config --global user.name &quot;yourName&quot;git config --global user.email &quot;yourEmail&quot; 查看设置 1git config --list 5.2 创建新的仓库Repository name : ‘Owner’.github.io 5.3 安装hexo-deployer-git1cnpm install --save hexo-deployer-git 5.4 设置_config.yml1234deploy: type: git repo: 仓库地址 brach: master 5.5 部署到远端1hexo d 参考手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo|codesheep","link":"/2019/10/08/hexo-blog/"},{"title":"oracle练习_1","text":"oracle课后练习。 使用SqlBeautifier格式化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540-- 登录数据库，完成以下题目 -- 1、显示所有部门名SELECT *FROM dept; -- 2、显示所有雇员名及其全年收入(工资+补助)，并指定列别名“年收入”SELECT ename , sal*12+nvl(comm,0) AS \"年收入\"FROM emp; -- 3、显示存在雇员的所有部门号SELECT DISTINCT deptnoFROM empWHERE ename IS NOT NULL; -- 4、显示工资超过2850的雇员名和工资SELECT ename , salFROM empWHERE sal &gt; 2850 ; -- 5、显示工资不在1500到2850之间的所有雇员名及工资SELECT ename , salFROM empWHERE sal &lt; 1500 OR sal &gt; 2850 ; -- 6、显示雇员代码为7566的雇员名及所在部门号SELECT ename , deptnoFROM empWHERE EMPNO = 7566 ;-- 7、显示部门代码为10和30中工资超过1500的雇员名及工资SELECT ename , salFROM empWHERE deptno in(10,30) AND sal &gt; 1500 ; -- 8、显示无管理者的雇员名及岗位SELECT ename , jobFROM empWHERE MGR IS NULL ;-- 9、显示所有雇员的平均工资、总计工资、最高工资、最低工资SELECT round(avg(sal),2) \"平均工资\" , sum(sal) 总计工资 , max(sal) 最高工资 , min(sal) 最低工资FROM emp ; -- 10、显示每种岗位的雇员总数、平均工资SELECT job 职位 , count(ename) 雇员总数 , round(avg(sal),2) 平均工资FROM empGROUP BY job ;-- 11、显示雇员总数，以及获得补助的雇员数SELECT count(ename) 雇员总数 , count(NULLIF(comm,0)) 补贴人数FROM emp ; -- 12、显示管理者的总人数SELECT COUNT (DISTINCT MGR)FROM emp ; -- 13、显示雇员工资的最大差额SELECT max(sal) - min(sal) 工资最大差额FROM emp ; -- 14、显示部门代码为20的部门号，以及该部门的所有雇员名、雇员工资及岗位SELECT deptno , ename , sal , jobFROM empWHERE deptno = 20 ; -- 15、显示获得补助的所有雇员名、补助额以及所在部门号SELECT ename , comm , deptnoFROM empWHERE comm &gt; 0 ; -- 16、显示所有雇员的姓名、部门编号、工资，并且列名要显示为中文SELECT ename 姓名 , deptno 部门编号 , sal 工资FROM emp ; -- 17、显示每个部门每个岗位的平均工资、每个部门的平均工资、每个岗位的平均工资SELECT deptno , job , avg(sal)FROM empGROUP BY deptno , job ;SELECT deptno , avg(sal)FROM empGROUP BY deptno ;SELECT job , avg(sal)FROM empGROUP BY job ; -- 18、显示工资大于1500的雇员名和工资，并且按照工资的降序排列SELECT ename , salFROM empWHERE sal &gt; 1500ORDER BY sal DESC ; -- 19、显示雇员部门编号为10或20的信息（要求使用IN关键字）SELECT *FROM deptWHERE deptno in(10,20) ; -- 20、显示雇员名的第二个字母为A的信息SELECT *FROM empWHERE substr(ename,2,1) = 'A' ; -- 21、显示没有发放补助的雇员信息SELECT *FROM empWHERE comm = 0 OR comm IS NULL; -- 22、显示雇员表中记录总数SELECT COUNT(*)FROM emp ; -- 23、显示所有雇员名、雇员工资及所在部门名SELECT e.ename , e.sal , d.dnameFROM emp e , dept dWHERE e.deptno = d.deptno ; -- 24、显示部门代码为20的部门名，以及该部门的所有雇员名、雇员工资及岗位SELECT d.dname , e.ename , e.sal , e.jobFROM dept d , emp eWHERE d.deptno = 20 AND e.deptno = 20 ; -- 25、显示所有雇员名、雇员工资及工资级别SELECT e.ename , e.sal , s.grade sal_levelFROM emp e , salgrade sWHERE e.sal BETWEEN s.losal AND s.hisal; -- 26、显示雇员“SCOTT”的管理者名SELECT enameFROM empWHERE empno = (SELECT mgr FROM emp WHERE ename = 'SCOTT') ; -- 27、显示获得补助的所有雇员名、补助额以及所在部门名SELECT e.ename , e.comm , d.dnameFROM emp e , dept dWHERE comm &gt; 0 ; -- 28、查询EMP表和SALGRADE表，显示部门代码为20的雇员名、工资及其工资级别SELECT e.ename , e.sal , s.gradeFROM emp e , salgrade sWHERE e.deptno = 20 AND e.sal BETWEEN s.losal AND s.hisal ; -- 29、显示部门代码为10的所有雇员名、部门名，以及其他部门名SELECT e.ename , d.dnameFROM emp eRIGHT JOIN dept d ON e.deptno = 10AND d.deptno = 10 ; -- 30、显示部门代码为10的所有雇员名、部门名，以及其他雇员名SELECT e.ename , d.dnameFROM emp eLEFT JOIN dept d ON e.deptno = 10AND d.deptno = 10 ;-- 31、显示部门代码为10的所有雇员名、部门名，以及其他部门名和雇员名SELECT e.ename , d.dnameFROM emp e , dept dWHERE e.deptno = d.deptno ; -- 32、显示\"BLAKE\"同部门的所有雇员，但不显示\"BLAKE\"SELECT enameFROM empWHERE deptno = (SELECT deptno FROM emp WHERE ename = 'BLAKE') AND ename != 'BLAKE'; -- 33、按以下格式显示下面的信息，条件是工资大于1500的。 部门名称 姓名 工资SELECT d.dname , e.ename , e.salFROM dept d , emp eWHERE d.deptno = e.deptno AND e.sal &gt; 1500 ; -- 34、按以下格式显示下面信息，条件是此人工资在所有人中最高。 部门 姓名 工资SELECT d.dname , e.ename , e.salFROM dept d , emp eWHERE d.deptno = e.deptno AND e.ename = (SELECT ename FROM emp WHERE sal = (SELECT max(sal) FROM emp)) ; -- 35、按以下格式显示下面信息 某人 为 某人 工作SELECT e.ename || '为' || mgr.ename || '工作' 工作关系FROM emp e , emp mgrWHERE mgr.empno = e.mgr ; -- 36、为所有人长工资，标准是：10部门长10%；20部门长15%；30部门长20%其他部门长18%（要求用DECODE函数）SELECT ename , sal , decode(deptno,10,sal*1.1,20,sal*1.15,30,sal*1.18) new_salFROM emp ; -- 37、根据工作年限长工资，标准是：为公司工作了几个月就长几个百分点。SELECT ename , sal , round(sal*(1+months_between(sysdate,hiredate)*0.01),2) new_salFROM emp ; -- 38、查询出king所在部门的部门号\\部门名称\\部门人数SELECT d.deptno 部门号, d.dname 部门名称, COUNT(e.ename) 部门人数FROM dept d, emp eWHERE e.deptno = d.deptnoGROUP BY d.deptno, d.dname HAVING d.deptno = (SELECT deptno FROM emp WHERE ename = 'KING'); -- 39、查询出king所在部门的工作年限最大的员工名字SELECT e.enameFROM emp eWHERE hiredate = (SELECT min(hiredate) FROM emp GROUP BY deptno HAVING deptno = (SELECT deptno FROM emp WHERE ename = 'KING')); -- 40、查询出管理员工人数最多的人的名字和他管理的人的名字SELECT mgr.ename, e.enameFROM emp mgr, emp eWHERE mgr.empno = e.mgr AND e.mgr = (SELECT mgr FROM emp GROUP BY mgr HAVING COUNT(mgr) &gt;= ALL (SELECT COUNT(mgr) FROM emp GROUP BY mgr)); -- 41、查询出工资成本最高的部门的部门号和部门名称SELECT e.deptno, d.dnameFROM emp e, dept dWHERE e.deptno = d.deptnoGROUP BY e.deptno, d.dname HAVING sum(e.sal) &gt;= (SELECT max(sum(sal)) FROM emp GROUP BY deptno) ; -- 42、查询出工资不超过2500的人数最多的部门名称SELECT d.dnameFROM dept dWHERE d.deptno = (SELECT deptno FROM emp GROUP BY deptno HAVING count(ename) = (SELECT max(count(ename)) FROM emp WHERE sal &lt; 2500 GROUP BY deptno)) -- 43、查询出没有下属员工的人的名字和他的职位SELECT e.ename, e.jobFROM emp e, (SELECT empno FROM emp minus SELECT DISTINCT mgr FROM emp) emWHERE e.empno = em.empno ; -- 44、查询出人数最多的那个部门的部门编号和部门名称SELECT e.deptno, d.dnameFROM emp e, dept dWHERE e.deptno = d.deptnoGROUP BY e.deptno, d.dname HAVING COUNT(empno) &gt;= (SELECT max(COUNT(empno)) FROM emp GROUP BY deptno) ; -- 45、查询出没有员工的那个部门的部门编号和部门名称(要求用两种方法,其中一种要用集合运算) --1 --2 集合SELECT d.deptno, d.dnameFROM dept d, (SELECT DISTINCT deptno FROM dept minus SELECT DISTINCT deptno FROM emp) deWHERE d.deptno = de.deptno; -- 46、查询出员工名字以A打头的人数最多的部门名称和员工名字SELECT d.dname, e.enameFROM dept d, emp eWHERE e.deptno = d.deptnoGROUP BY d.dname, e.ename HAVING e.ename LIKE 'A%'AND COUNT(e.ename) &gt;= (SELECT max(COUNT(ename)) FROM (SELECT ename, deptno FROM emp WHERE ename LIKE 'A%') GROUP BY deptno) ; -- 47、现在公司要给员工增加工龄工资,规则是:30*工作年限，请按以下格式显示下面结果: 部门名称 员工姓名 原工资 增加额度 新工资SELECT d.dname 部门名称, e.ename 员工姓名, e.sal 原工资, round(30 * (months_between(sysdate, e.hiredate) / 12)) 增加额度, round(e.sal + (1 + (30 * (months_between(sysdate, e.hiredate) / 12)))) 新工资FROM dept d, emp eWHERE e.deptno = d.deptno; -- 48、针对DEPT和EMP表，查询出下面格式的结果并要求按部门编号和工资降序排列。 部门名称 员工姓名 工资SELECT d.dname 部门名称 , e.ename 员工姓名 , e.sal 工资FROM dept d , emp eWHERE d.deptno = e.deptnoORDER BY e.deptno DESC , e.sal DESC ; -- 49、针对DEPT和EMP表，查询出下面格式的结果。 -- 部门编号 部门名称 部门工资最小值 部门工资最大值 部门工资平均值 部门工资合计值SELECT d.deptno 部门编号, d.dname 部门名称, min(e.sal) 部门工资最小值, max(e.sal) 部门工资最大值, round(avg(e.sal)) 部门工资平均值, sum(e.sal) 部门工资合计值FROM dept dLEFT JOIN emp e ON d.deptno = e.deptnoGROUP BY d.deptno , d.dnameORDER BY d.deptno; -- 50、针对DEPT和EMP表，查询出SMITH所在部门的部门名称、部门工资平均值。（要求使用子查询）SELECT d.dname, avg(e.sal)FROM dept d, emp eWHERE e.deptno = (SELECT deptno FROM emp WHERE ename = 'SMITH') AND d.deptno = e.deptnoGROUP BY d.dname; -- 51、针对DEPT和EMP表，查询出下面格式的结果。（要求使用外连接，没有员工的部门名也要显示。员工姓名如果是空值，要求用“不存在”代替；如果工资是空值，要求用0代替。） -- 部门名称 员工姓名 工资SELECT d.dname 部门名称 , nvl(e.ename,'不存在') 员工姓名 , nvl(e.sal,'0') 工资FROM dept dLEFT JOIN emp e ON d.deptno = e.deptno ; -- 52、针对DEPT和EMP表，查询出没有员工的部门号和部门名称（要求用两种方法） --1SELECT deptno , dnameFROM deptWHERE deptno = (SELECT DISTINCT deptno FROM dept minus SELECT DISTINCT deptno FROM emp) ; --2-- 53、查询出平均工资最高的部门编号、部门名称和平均工资。SELECT d.deptno 部门编号, d.dname 部门名称, round(avg(e.sal), 2) 平均工资FROM dept d, emp eWHERE d.deptno = e.deptnoGROUP BY d.deptno, d.dname HAVING avg(e.sal) = (SELECT max(avg(sal)) FROM emp GROUP BY deptno) ; -- 54、查询出工资高于全体平均工资人数最多的部门编号、部门名称和员工姓名、工资。SELECT d.deptno, d.dname, e.ename, e.salFROM dept d, emp eWHERE d.deptno = e.deptno AND e.sal &gt; (SELECT avg(sal) FROM emp) AND e.deptno = (SELECT deptno FROM (SELECT deptno, ename, sal FROM emp WHERE sal &gt; (SELECT avg(sal) FROM emp)) GROUP BY deptno HAVING COUNT(ename) = (SELECT max(COUNT(ename)) FROM (SELECT deptno, ename, sal FROM emp WHERE sal &gt; (SELECT avg(sal) FROM emp)) GROUP BY deptno)) ;","link":"/2019/10/01/oracle-practice-10-1/"},{"title":"3-Oracle","text":"3-oracle [TOC] 1.多表查询1.1 连接查询 笛卡尔集(Cross Join) 等值连接(Equijoin)(Natural join..on) 非等值连接(Non-Equijoin) 自连接(Self join) 左外联接（Left Outer Join ） 右外联接（Right Outer Join） 满外联接（Full Outer Join） 内连接 （inner join） 12345678910111213141516171819202122232425262728293031323334353637383940--(笛卡尔集)员工表emp和部门表dept的笛卡尔集（笛卡尔集表=列数之和，行数之积，笛卡尔集表内中有些数据是不符合要求的）--多表查询没有连接条件，或者连接条件无效--使用等值连接/内连接（只能使用=号），显示员工的编号，姓名，部门名，使用表别名简化--使用非等值连接（不能使用=号，其它符号可以，例如：&gt;=，&lt;=，&lt;&gt;，betwen and等），显示员工的编号，姓名，月薪，工资级别--内连接查询：只能查询出符合条件的记录--外连接查询：既能查询出符合条件的记录（内连接查询到的），还返回左（或右）表中不满足条件的行/*使用外连接，按部门10,20,30,40号，统计各部门员工人数，要求显示部门号，部门名，人数部门号 部门名 人数10 ACCOUNTING 3 20 RESEARCH 530 SALES 640 OPERATIONS 0等值连接/非等值连接/内连接：只会查询出多张表中，根据某个字段匹配，符合条件的记录，不符合条件的记录是不会存在的*/--左外连接[是oracle专用的，不是SQL99规则]，或者使用通用的left [outer] join--右外连接：，或者使用通用的right [outer] join--使用左外连接，按部门10,20,30,40号，统计各部门员工人数，要求显示部门号，部门名，人数，且按人数降序排列--使用自连接，显示\"SMITH的上级是FORD\"这种格式只有13条记录，不含有KING--基于上述问题，将KING的上级是“”显示出来14条记录注意：自连接也用到内连接和外连接 1.2 集合操作12345678910111213141516171819202122232425262728293031323334353637/* 联合查询是对多个查询结果集进行处理，有如下四个处理方式： 1.union：取并集，但是有重复记录会去重【去重】 2.union all：取并集，有重复记录不会去重【不去重】 3.INTERSECT:取交集，即两个查询结果中共有的记录 4.MINUS:取差集，返回第一个查询检索出的记录减去第二个查询检索出的记录之后剩余的记录 面试：union和union all的区别*/--使用并集运算，查询20号部门或30号部门的员工信息 ：取并集--使用交集运算[intersect]，查询工资在1000-2000和1500-2500之间的员工信息（方式一）--用where行过滤，查询工资在1000-2000和1500-2500之间的员工信息（方式二）--使用差集运算[minus]，查询工资在1000-2000，但不在1500-2500之间的员工信息（方式一）--使用where行过滤，查询工资在1000-2000，但不在1500-2500之间的员工信息（方式二）--集合查询的细节：--使用集合查询的列的个数要一致select e.ename,e.deptno,e.sal from emp eunion select e.ename,e.deptno from emp e;--使用集合查询的列的数据类型要一样select e.ename,e.deptno,e.sal from emp eunion select e.hiredate,e.deptno,e.sal from emp e;--小结：在可以实现同一个功能的时候，我们一般这么选择：多表查询 &gt; 子查询 &gt; 集合查询 2.子查询##2.1 单行/多行子查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* 子查询的作用：查询条件未知的事物 查询条件已知的问题：例如：查询工资为800的员工信息 查询条件未知的问题：例如：查询工资为20号部门平均工资的员工信息 一个条件未知的问题，可以分解为多个条件已知的问题*/--查询工资比WARD高的员工信息--方法1：分两步查--第一：查询WARD的工资? --第二：查询工资比1250高的员工信息？ --方法2：子查询 --方法3：自连接查询 --查询部门名为'SALES'的员工信息--方式1：子查询/*子查询细节：1）子查询与父查询可以针对同一张表 2）子查询与父查询可以针对不同张表3) 子查询与父查询在传递参数时，数量要相同4) 子查询与父查询在传递参数时，类型要相同5) 子查询与父查询在传递参数时，含义要相同*/--方式2：多表查询--查询每个员工编号,姓名，部门名,工资等级（三表查询，这三张表并无外健关联）--查询工资最低的员工信息（单行子查询，使用=号）--查询部门名为'ACCOUNTING'或'SALES'的员工信息（多行子查询，使用in关键字） --查询工资比20号部门【任意any】一个员工工资【低&lt;】的员工信息（多行子查询，使用any关键字） --查询工资比30号部门【所有all】员工【低&lt;】的员工信息（多行子查询，使用all关键字） --返回job与7499号员工相同，sal比7654号员工多的员工姓名，job 和工资--查询平均工资最低的部门信息--查询平均工资最低的部门信息和该部门的平均工资select d.*, (select avg(sal) from emp where deptno = d.deptno)from dept dwhere d.deptno = (--部门平均工资最低值对应的no SELECT deptno FROM emp GROUP BY deptno HAVING avg(sal) = (--部门平均工资最低值 SELECT min(avg(sal)) FROM emp GROUP BY deptno ) );--查询平均工资高于公司平均工资的部门有哪些?--查询 1981 年来公司的所有员工的最高工资的那个员工的信息. 2.2 子查询注意事项如果子查询未返回任何行，则主查询也不会返回任何结果 1234SQL&gt; select * from emp where sal &gt; (select sal from emp where empno = 8888); EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO----- ---------- --------- ----- ----------- --------- --------- ------ 如果子查询返回单行结果，则为单行子查询，可以在主查询中对其使用相应的单行记录比较运算符 1234567SQL&gt; select * from emp where sal &gt; (select sal from emp where empno = 7566); EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO----- ---------- --------- ----- ----------- --------- --------- ------ 7788 SCOTT ANALYST 7566 1987/4/19 3000.00 20 7839 KING PRESIDENT 1981/11/17 5000.00 10 7902 FORD ANALYST 7566 1981/12/3 3000.00 20 如果子查询返回多行结果，则为多行子查询，此时不允许对其使用单行记录比较运算符 12345SQL&gt; select * from emp where sal &gt; (select avg(sal) from emp group by deptno); select * from emp where sal &gt; (select avg(sal) from emp group by deptno) ORA-01427: 单行子查询返回多个行 2.3 exists vs in​ 对于 in 和 exists 的性能区别: ​ 如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用 in,反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用 exists。其实我们区分 in 和 exists 主要是造成了驱动顺序的改变（这是性能变化的关键），如果是 exists，那么以外层表为驱动表，先被访问，如果是 IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了另外 IN 是不对 NULL 进行处理 . 12345678910111213141516171819202122232425SQL&gt; select * from emp where null in (1,null); EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO----- ---------- --------- ----- ----------- --------- --------- ------ SQL&gt; select * from emp where 1 in (1,null); EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO----- ---------- --------- ----- ----------- --------- --------- ------ 7369 SMITH CLERK 7902 1980/12/17 800.00 20 7499 ALLEN SALESMAN 7698 1981/2/20 1600.00 300.00 30 7521 WARD SALESMAN 7698 1981/2/22 1250.00 500.00 30 7566 JONES MANAGER 7839 1981/4/2 2975.00 20 7654 MARTIN SALESMAN 7698 1981/9/28 1250.00 1400.00 30 7698 BLAKE MANAGER 7839 1981/5/1 2850.00 30 7782 CLARK MANAGER 7839 1981/6/9 2450.00 10 7788 SCOTT ANALYST 7566 1987/4/19 3000.00 20 7839 KING PRESIDENT 1981/11/17 5000.00 10 7844 TURNER SALESMAN 7698 1981/9/8 1500.00 0.00 30 7876 ADAMS CLERK 7788 1987/5/23 1100.00 20 7900 JAMES CLERK 7698 1981/12/3 950.00 30 7902 FORD ANALYST 7566 1981/12/3 3000.00 20 7934 MILLER CLERK 7782 1982/1/23 1300.00 10 14 rows selected 例子： 12345678910111213141516171819SQL&gt; select * from emp a where exists (select sal from emp e where a.sal &gt; 2500) order by a.ename; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO----- ---------- --------- ----- ----------- --------- --------- ------ 7698 BLAKE MANAGER 7839 1981/5/1 2850.00 30 7902 FORD ANALYST 7566 1981/12/3 3000.00 20 7566 JONES MANAGER 7839 1981/4/2 2975.00 20 7839 KING PRESIDENT 1981/11/17 5000.00 10 7788 SCOTT ANALYST 7566 1987/4/19 3000.00 20 SQL&gt; select * from emp where sal in (select sal from emp where sal &gt; 2500) order by ename; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO----- ---------- --------- ----- ----------- --------- --------- ------ 7698 BLAKE MANAGER 7839 1981/5/1 2850.00 30 7902 FORD ANALYST 7566 1981/12/3 3000.00 20 7566 JONES MANAGER 7839 1981/4/2 2975.00 20 7839 KING PRESIDENT 1981/11/17 5000.00 10 7788 SCOTT ANALYST 7566 1987/4/19 3000.00 20 第二个例子： 123456789101112SQL&gt; select * from emp e where exists (select mgr from emp b where e.mgr is null); EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO----- ---------- --------- ----- ----------- --------- --------- ------ 7839 KING PRESIDENT 1981/11/17 5000.00 10 SQL&gt; select * from emp e where e.mgr in (null); EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO----- ---------- --------- ----- ----------- --------- --------- ------ SQL&gt; ​ EXISTS的执行流程 123456789select * from t1 where exists ( select null from t2 where y = x )-- 可以理解为:for x in ( select * from t1 ) loop if ( exists ( select null from t2 where y = x.x ) then OUTPUT THE RECORD end if end loop #3.TopN 查询【分析函数】 123456789101112131415161718192021222324/* 分析函数根据一组行来计算聚合值 用于计算完成聚集的累计排名等 分析函数为每组记录返回多个行 以下三个分析函数用于计算一个行在一组有序行中的排位，序号从1开始 ROW_NUMBER 返回连续的排位，不论值是否相等，直接往后数 RANK 具有相等值的行排位相同，序数随后跳跃，比如：有两个第一名时，第三个的排名是3 DENSE_RANK 具有相等值的行排位相同，序号是连续的，比如：有两个第一名时，第三个的排名是2*/--找出公司所有人工资排名--求每个部门工资前3名的人姓名、部门、工作和工资--给emp表中每种工作工资由高到低进行排序：--总结：--①Over函数指明在那些字段上做分析，其内跟Partition by表示对数据进行分组。注意Partition by可以有多个字段。--over函数是oracle特有的一个特殊函数--②Over函数可以和其它聚集函数、分析函数搭配，起到不同的作用。例如这里的SUM，还有诸如Rank，Dense_rank等。 #4.分页查询[重点] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/*什么是Oracle伪列？Oracle 中伪列就像一个表列，但是它并没有存储在表中，即我们在设计表的时候，并没有定义这个字段，但是可以直接拿来用。伪列可以从表中查询，但不能插入、更新和删除它们的值常用的伪列：ROWID：它是表中行的存储地址，该地址可以唯一地标识数据库中的一行，可以使用 ROWID 伪列快速地定位表中的一行 什么是rownum，有何特点 1）rownum是oracle专用的关健字 2）rownum与表在一起，表亡它亡,表在它在 3）rownum在默认情况下，从表中是看不出来的 4）只有在select子句中，明确写出rownum才能显示出来 5）rownum是number类型，且唯一连续 6）rownum最小值是1，最大值与你的记录条数相同 7）基于rownum的特性，我们通常rownum只用于&lt;或&lt;=关系运算 8）在Oracle中，分页就是使用rownum，同时结合子查询*/--显示emp表中3-8条记录（方式一：使用集合减运算）select empno,ename,rownum from emp where rownum&lt;=8minusselect empno,ename,rownum from emp where rownum&lt;=2;--显示emp表中3-8条记录（方式二：使用子查询，在from子句中使用，重点）-- rownum是跟随表/或查询结果的存在而存在，rownum只能单独使用，不能使用表名/别名.rownum-- 所以，在子查询中使用rownum的时候，通常为rownum设置一个别名-- 同时，为子查询设置一个别名select t.empno,t.ename,t.rnfrom(select empno,ename,rownum rn from emp where rownum&lt;=8) twhere t.rn&gt; 2--oracle中，分页的常用格式即下面的写法-- 需求1：1页显示4条数据,查询第1页数据【测试第一页，只针对第一页有效，不通用，不对的】select empno,ename,rownum from emp where rownum &lt;=4-- 需求2：1页显示4条数据,查询第2页数据-- 公式：①子查询中rownum &lt;= 当前页*每页的条数-- ②在外层查询中，t.rn &gt; (当前页-1)*每页的条数 -- Oracle的分页需要注意的几点-- 1.使用rownum实现-- 2.使用子查询-- 3.分页中两个未知参数的计算公式-- 4.若想去表的所有字段，又想使用*，使用表名.*;where的rownum不能使用别名替代select t.empno,t.ename,t.rn -- select t.*from(select empno,ename,rownum rn from emp where rownum &lt;=12) twhere t.rn &gt; 8--显示emp表中5-9条记录--显示emp表中薪水最高的前5人select t.*--,rownumfrom(select * from emp order by sal desc) twhere rownum&lt;=5--使用分析函数 -- row_number()select t.*from(select emp.*,row_number() over(order by sal desc) rank from emp) twhere t.rank&lt;=5--emp表中薪水排名第5的员工信息select t.*from(select emp.*,row_number() over(order by sal desc) rank from emp) twhere t.rank=5select e.*from ( --对排序后的结果，使用rownum取前5条select t.*,rownum rnfrom( -- 对所有数据做全局排序select * from emp order by sal desc) twhere rownum&lt;=5) ewhere e.rn=5 --按照排序的分页通常这么写【按照sal排序，每页3条数据，取第2页】select e.* --3.取指定页数的数据 即 rn &gt; (当前页-1)*每页条数from (select t.*,rownum rn --2.取前n页的数据 rownum &lt;= 当前页*每页条数from( -- 1.对整体数据进行排序select * from emp order by sal desc ) twhere rownum &lt;=6 ) ewhere e.rn &gt; 3-- 补充需求：按照工资降序，同时查询条件 sal &gt; 1000,若有其他条件，依次类推--1.带查询条件，但不带分页的查询select * from emp where sal &gt; 1000 order by sal desc; -- t--2.取前n页的数据 rownum &lt;= 当前页*每页条数select t.*,rownum rnfrom twhere rownum &lt;= 6 -- e--3.从e中查询指定页数的数据select e.*from ewhere e.rn &gt; 3--拼接select e.*from (select t.*,rownum rnfrom (select * from emp where sal &gt; 1000 order by sal desc)twhere rownum &lt;= 6) ewhere e.rn &gt; 3--思考：如何求总记录数 totalCounts select count(t.empno) from (select * from emp where sal &gt; 1000 order by sal desc) t-- 如何求总页数? 每页数据pageSize=5 totalCounts 对 pageSize 取余数--若余数=0，总页数=totalCounts / pageSize-- 若余数!=0,总页数=totalCounts / pageSize + 1 5. 练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251-- 列出员工表中每个部门的员工数，和部门 no-- 列出员工表中每个部门的员工数（员工数必须大于 3），和部门名称select d.deptno,d.dname,count(e.deptno)from emp e right join dept don e.deptno = d.deptnogroup by d.deptno,d.dnamehaving count(e.deptno) &gt;= 3order by count(e.deptno) desc;-- 找出工资比 jones 多的员工select *from empwhere sal &gt; (select sal from emp where ename='JONES');-- 列出所有员工的姓名和其上级的姓名select e1.ename,e2.ename 上级姓名from emp e1 left join emp e2 --使用左外连接，目的是没有上级的也要显示on e1.mgr = e2.empno-- 以职位分组，找出平均工资最高的两种职位-- 1.求出按照职位分组的所有平均工资，且按照降序排列select job,avg(sal)from emp group by joborder by avg(sal) desc-- 2.从1的查询结果中，取出前2条即可select t.*--,rownumfrom(select job,avg(sal)from emp group by joborder by avg(sal) desc) twhere rownum&lt;=2-- 查找出不在部门 20，且比部门 20 中任何一个人工资都高的员工姓名、部门名称-- 1.找出20号部门的sal列表 --也可以使用maxselect sal from emp where deptno=20; --1000,3000,5000-- 2.找出工资大于1中的每个值--方法1：select e.ename,d.deptno,d.dname,e.salfrom emp e left join dept d on e.deptno = d.deptnowhere sal &gt; all(select sal from emp where deptno=20)and e.deptno != 20 or e.deptno is null--方法2：select dept.deptno,dept.dname,t.salfrom dept right join (select ename,deptno,salfrom emp where sal &gt; all(select sal from emp where deptno=20)and deptno != 20 or deptno is null) ton dept.deptno = t.deptno-- 得到平均工资大于 2000 的工作职种-- 分部门得到工资大于 2000 的所有员工的平均工资，并且平均工资还要大于 2500select deptno,avg(sal) --2.在1的过滤结果上，分部门计算平均工资from empwhere sal &gt; 2000 --1.过滤出工资大于2000的员工group by deptnohaving avg(sal) &gt; 2500; --3. 对分组后的数据进行过滤-- 得到每个月工资总数最少的那个部门的部门编号，部门名称，部门位置-- 方式1：-- 1.对不同部门进行工资的汇总select deptno,sum(sal) minsalfrom empgroup by deptno;-- 2.找出1中的最小工资及其deptno --可以使用min，也可以使用rownum[在1中需要排序]select deptno,sum(sal) minsalfrom empgroup by deptnohaving sum(sal) = (select min(t.minsal)from (select deptno,sum(sal) minsalfrom empgroup by deptno) t)-- 3.使用2的结果去关联dept表，查询出需要的字段即可select d.deptno,d.dname,e.minsalfrom dept d inner join ( select deptno,sum(sal) minsal from emp group by deptno having sum(sal) = ( select min(t.minsal) from (select deptno,sum(sal) minsal from emp group by deptno) t)) eon d.deptno = e.deptno--方式2：-- 1.对不同部门进行工资的汇总select deptno,sum(sal) minsalfrom empgroup by deptnoorder by minsal;-- 2.找出1中的最小工资及其deptno --可以使用min，也可以使用rownum[在1中需要排序]select t.*from ( select deptno,sum(sal) minsal from emp group by deptno order by minsal) twhere rownum &lt;=1-- 3.使用2的结果去关联dept表，查询出需要的字段即可select e.*,d.dname,d.locfrom dept d join ( select t.* from ( select deptno,sum(sal) minsal from emp group by deptno order by minsal ) t where rownum &lt;=1) eon e.deptno = d.deptno-- 分部门得到平均工资等级为 2 级（等级表）的部门编号-- 1.算出各部门的平均工资 tselect deptno,avg(sal) avgsalfrom empgroup by deptno-- 2.使用t去关联salgradeselect t.deptno,t.avgsal,s.gradefrom ( select deptno,avg(sal) avgsal from emp group by deptno) t,salgrade swhere t.avgsal between s.losal and s.hisaland s.grade = 3-- 查找出部门 10 和部门 20 中，工资最高第 3 名到工资第 5 名的员工的员工名字，部门名字，部门位置--方式1：-- 1.过滤出deptno为10和20的员工，且按照工资排序select emp.*,row_number() over(order by sal desc) rankfrom empwhere deptno in(10,20)--2.在1的基础之上，关联了dept这个表select t.*,d.dname,d.locfrom ( select emp.*,row_number() over(order by sal desc) rank from emp where deptno in(10,20)) t,dept dwhere t.rank &gt;=3 and t.rank &lt;=5and t.deptno=d.deptno--方式2：-- 1.过滤出deptno为10和20的员工，且按照工资排序select emp.*from empwhere deptno in(10,20)order by sal desc--2.在1的基础之上,使用rownum取前5条select t.*,rownum rnfrom ( select emp.* from emp where deptno in(10,20) order by sal desc) twhere rownum &lt;=5--3.在2的基础上，取出3-5条，同时关联dept表select e.*,d.dname,d.locfrom( select t.*,rownum rn from ( select emp.* from emp where deptno in(10,20) order by sal desc ) t where rownum &lt;=5) e,dept dwhere e.rn &gt;2 and e.deptno=d.deptno-- 查找出收入（工资加上奖金），下级比自己上级还高的员工编号，员工名字，员工收入-- 思路：员工emp，上级emp --考虑，没有上级的员工是否参与比较select e1.empno,e1.ename,e1.sal+nvl(e1.comm,0),e2.empno,e2.ename,e2.sal+nvl(e2.comm,0)from emp e1,emp e2where e1.mgr = e2.empnoand e1.sal+nvl(e1.comm,0) &gt; e2.sal+nvl(e2.comm,0)-- 查找出工资等级不为 4 级的员工的员工名字，部门名字，部门位置select e.*,d.dname,d.loc,s.gradefrom emp e,dept d,salgrade swhere e.deptno=d.deptnoand e.sal between s.losal and s.hisaland s.grade &lt;&gt; 4-- 查找出职位和'MARTIN' 或者'SMITH'一样的员工的平均工资-- 1.找出'MARTIN' 或者'SMITH'的职位select job from emp where ename in('MARTIN' ,'SMITH')-- 2.计算CLERK和SALESMAN的平均工资select job,avg(sal)from empwhere job in (select job from emp where ename in('MARTIN' ,'SMITH'))group by job-- 查找出不属于任何部门的员工-- 按部门统计员工数，并按照部门员工数多到少取人数的第二名到第五名（列出部门名字，部门位置）select e.*from( select t.*,rownum rn from ( select deptno,count(empno) from emp group by deptno order by 2 desc) t where rownum &lt;=5 ) e where e.rn &gt; 1 -- 查询出 king 所在部门的部门号\\部门名称\\部门人数select d.deptno,d.dname,t.deptncountfrom dept d inner join (--统计king所在部门的人数select deptno,count(deptno) deptncountfrom empwhere deptno = (select deptno from emp where ename='KING') --找出king所在的部门group by deptno) ton d.deptno = t.deptno-- 查询出 king 所在部门的工作年限最大的员工名字select t.*,rownumfrom(select *from empwhere deptno = (select deptno from emp where ename='KING')order by hiredate asc) twhere rownum &lt;=1;-- 查询出工资成本最高的部门的部门号和部门名称select d.deptno,d.dname,t.deptsumfrom dept d join (select deptno,sum(sal) deptsumfrom empgroup by deptnoorder by deptsum desc) ton t.deptno = d.deptnowhere rownum &lt;=1 6. 高级查询[了解]6.1 随机返回 5 条记录 :dbms_random.value()12345678--生成一个0~1间的随机小数（包括0，不包括1）--生成一个1~10间的随机小数（包括1和不包括10）select dbms_random.value(1,10) from dual;--需求：从emp表中随机抽取5个员工信息：名字和工作select * from (select ename, job from emp order by dbms_random.value()) where rownum &lt;= 5 6.2 处理空值排序 :nulls last(first)123-- 如果Order by 中指定了表达式Nulls first则表示null值的记录将排在最前(不管是asc 还是 desc)-- 如果Order by 中指定了表达式Nulls last则表示null值的记录将排在最后 (不管是asc 还是 desc)select * from emp order by comm nulls last 6.3 查询跳过表中的偶数行 :row_number() over ()1select * from (select row_number() over(order by e.ename) rn ,e.* from emp e) x where mod(x.rn,2)=1; 6.4 查询员工信息与其中工资最高最低员工12-- over()窗口函数，之前没有加over，我们的聚合函数必须跟分组在一起使用，over()将每条记录看成一个窗口select ename,sal,max(sal) over(), min(sal) over() from emp; 6.5 连续求和1select ename,sal,sum(sal) over(), sum(sal) over(order by ename) from emp; 6.6 分部门连续求和1select ename,sal,sum(sal) over(), sum(sal) over(partition by deptno order by ename) as sum,deptno from emp; 6.7 得到当前行上一行或者下一行的数据1select ename,sal,lead(sal) over(order by sal) as lead ,lag(sal) over(order by sal) from emp; 6.8 根据子串分组1select to_char(hiredate,'yyyy'),avg(sal) from emp group by to_char(hiredate,'yyyy'); 6.9 确定一年内的天数1select add_months(trunc(sysdate,'y'),12)-trunc(sysdate,'y') from dual; 6.10 查询 EMP 员工表下每个部门工资前二名的员工信息1select* from (select e.*,row_number() over(partition by deptno order by empno) rn from emp e) a where a.rn &lt;=2;","link":"/2019/10/11/3-Oralce/"},{"title":"4-Oracle","text":"4-oracle [TOC] 1.数据字典[了解]123456789101112131415161718192021/* 了解 1.什么是数据字典 数据字典是Oracle存放有关数据库信息的地方，其用途是用来描述数据的（数据的数据：元数据）.比如一个表的创建者信息，创建时间信息，所属表空间信息，用户访问权限信息等. 2.数据字典分类 1）静态数据字典 主要是在用户访问数据字典时不会发生改变的，主要由表和视图组成 注意：数据字典中的表是不能直接被访问的，但是可以访问数据字典中的视图 静态数据字典中的视图分为三类，它们分别由三个前缀够成：user_*、 all_*、 dba_* ①user_* 该视图存储了关于当前用户所拥有的对象的信息。（即所有在该用户模式下的对象） ②all_* 该试图存储了当前用户能够访问的对象的信息。（与user_*相比，all_* 并不需要拥有该对象，只需要具有访问该 对象的权限即可） ③dba_* 该视图存储了数据库中所有对象的信息。（前提是当前用户具有访问这些数据库的权限，一般来说必须具有管理员权 限） 2）动态数据字典 它依赖数据库运行的性能，反映数据库运行的一些内在信息。Oracle包含了一些潜在的由系统管理员如SYS维护的表和视图，由于当数据库运行的时候它们会不断进行更新，所以称它们为动态数据字典（或者是动态性能视图） Oracle中这些动态性能视图都是以v$开头的视图，比如v$access */ 1.1 查询某用户下所有的表1select table_name from all_tables where owner='scott' 1.2 查询EMP表中所有的字段1select * from all_tab_columns where table_name='EMP' 1.3 列出表的索引列1select * from sys.all_ind_columns where table_name='EMP' 1.4 列出表中约束1select * from all_constraints where table_name='EMP' 1.5 在 oracle 中描述数据字典视图1select table_name ,comments from dictionary where table_name like '%TABLE%'; 2.Oracle 数据类型【重点】 类型 含义 CHAR(length) 存储固定长度的字符串。参数 length 指定了长度，如果存储的字符串长度小于 length，用空格填充。默认长度是 1，最长不超过 2000 字节。 VARCHAR2(length) 存储可变长度的字符串。length 指定了该字符串的最大长度。默认长度是 1，最长不超过 4000 字符。 NUMBER(p，s) 既可以存储浮点数，也可以存储整数，p 表示数字的最大位数（如果是小数包括整数部分和小数部分和小数点，p 默认是 38 位），s 是指小数位数。 DATE 存储日期和时间，存储纪元、4 位年、月、日、时、分、秒，存储时间从公元前 4712 年 1 月 1 日到公元后 4712 年 12 月 31 日。 TIMESTAMP 不但存储日期的年月日，时分秒，以及秒后 6 位，同时包含时区。 CLOB 存储大的文本，比如存储非结构化的 XML 文档 BLOB 存储二进制对象，如图形、视频、声音等。 3.Oracle 体系结构(DBA，了解)一系列物理文件（数据文件，控制文件，联机日志等）的集合或与之对应的逻辑结构（表空间，段等）被称为数据库 物理存储结构：数据文件、重做日志文件、控制文件desc v$logfile;select member from v$logfile;v$controlfile;v$datafile;逻辑存储结构：表空间、段、区、块 创建表空间 123456create tablespace user_data datafile 'D:\\oracle\\oradata\\user_data.dbf' size 50m autoextend on /*autoextend on 表空间大小不够用时自动扩展*/next 50m maxsize 20480m /*next 50m 自动扩展增量为50MB */extent management local; /*extent management local 代表管理方式为本地*/ 所谓本地化管理，就是指Oracle不再利用数据字典表来记录Oracle表空间里面的区的使用状况，而是在每个表空间的数据文件的头部加入了一个位图区，在其中记录每个区的使用状况。每当一个区被使用，或者被释放以供重新使用时，Oracle都会更新数据文件头部的这个记录，反映这个变化。创建临时表空间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051create temporary tablespace user_temp tempfile 'D:\\oracle\\oradata\\user_temp.dbf' size 50m autoextend on next 50m maxsize 20480m extent management local;/* 1.表分区:把表中数据划分成若干部分，并存储在不同的位置，垂直拆分 针对表的字段特别多，一张表来维护的话，比较困难，通常需要垂直拆分 水平拆分：采用分库策略，针对单表的数据量比较大的时候，需要进行水平拆分 ，字典：A-H、I-k..... 2.优点 改善查询性能 表更容易管理 便于备份和恢复 提高数据安全性 3.表分区分类 范围分区：列值的范围作为划分条件 散列分区：列的hash值自动分配 列表分区：列值必须明确指定，一个分区列 复合分区：先按第一分区方法分区、再按第二分区方法划分子分区 其他分区*/-- 范围分区CREATE TABLE SALES1( SALES_ID NUMBER, PRODUCT_ID VARCHAR2(5), SALES_DATE DATE NOT NULL, SALES_COST NUMBER(10), AREACODE VARCHAR2(5))PARTITION BY RANGE (SALES_DATE)( PARTITION P1 VALUES LESS THAN (to_date('2013-04-1', 'yyyy-mm-dd')), PARTITION P2 VALUES LESS THAN (to_date('2013-07-1', 'yyyy-mm-dd')), PARTITION P3 VALUES LESS THAN (to_date('2013-10-1', 'yyyy-mm-dd')), PARTITION P4 VALUES LESS THAN (to_date('2014-01-1', 'yyyy-mm-dd')), partition P5 VALUES LESS THAN (maxvalue));INSERT INTO SALES1 VALUES (1,'P1',to_date('2013-04-1', 'yyyy-mm-dd'),10,'025');INSERT INTO SALES1 VALUES (2,'P2',to_date('2015-01-1', 'yyyy-mm-dd'),10,'025');SELECT * FROM SALES1 partition(P1);SELECT * FROM SALES1 partition(P2);SELECT * FROM SALES1 partition(P3);SELECT * FROM SALES1 partition(P4);SELECT * FROM SALES1 partition(P5); 3.1 表空间​ 在数据库系统中，存储空间是较为重要的资源，合理利用空间，不但能节省空间，还可以提高系统的效率和工作性能。Oracle 可以存放海量数据，所有数据都在数据文件中存储。而数据文件大小受操作系统限制，并且过大的数据文件对数据的存取性能影响非常大。同时Oracle 是跨平台的数据库，Oracle 数据可以轻松的在不同平台上移植，那么如何才能提供统一存取格式的大容量呢？Oracle 采用表空间来解决。 ​ 表空间只是一个逻辑概念，若干操作系统文件（文件可以不是很大）可以组成一个表空间。表空间统一管理空间中的数据文件，一个数据文件只能属于一个表空间。一个数据库空间由若干个表空间组成。如图所示： 3.2 表数据的存储方式 1、表空间 ​ 表空间是 oracle 数据库最大的逻辑存储单元，数据库的大小从逻辑上看就是由表空间决定的，所有表空间大小的和就是数据库的大小。在 oracle 数据库中，存储结构管理主要就是通过对表空间的管理啊来实现的。表空间与数据库文件直接关联，一个表空间包含一个或多个数据文件，一个数据文件只能从属于一个表空间，数据库对象就是存储在表空间对应的 一个或多个数据文件中。 ​ 表空间根据存储数据类型的不同，分为系统表空间和非系统表空间两类。 ​ 系统表空间：主要存放数据库的系统信息，如数据字典、数据库对象定义信息，数据库组件信息等。 ​ 非系统表空间：又分为撤销表空间、临时表空间和用户表空间等。其中撤销表空间用于自动管理数据库的回退信息，临时表空间用于管理数据库的临时信息。用户表空间用于存储业务数据。 2、段 ​ 段是由一个或多个连续或不连续的区组成的逻辑存储单元，用于存储特定的、具有独立存储结构的数据库对象。根据存储对象类型不同，分为：表段、索引段、临时段和回退段4类。 ​ 表段：又称数据段，用来存储表或簇的数据，可以细分为普通表段、分区表段、簇段、索引化表段 ​ 索引段：用来存放索引数据，包括 ROWID 和索引值 ​ 临时段：是进行查询、排序等操作时，如果内存空间不足，用于保存 sql 语句在解释和执行过程中产生的临时数据。会话结束时，为该操作分配的临时段将被释放。 ​ 回退段：用于保存数据库的回退信息，包含当前未提交事务所修改的数据的原始版本。利用回退段中保存的回退信息，可以实现事务回滚、数据库恢复、数据的读一致性和闪回查询。 3、区（一张表可以存放于一个或多个区） 区是由一系列连续的数据块构成的逻辑存储单元，是存储空间分配的最小单元。当创建一个数据库对象时，oracle 为对象分配若干个区。以构成 一个段来为对象提供初始的存储空间。当段中已分配的区都写满后，oracle 会为段分配一个新区，以容纳更多的数据。构成一个段的所有区只能是在个文件中。oracle 数据库中，引入区的目的是为了提高系统存储空间分配的效率，以区为单位的存储空间分配大大减少了磁盘分配的次数。4、块 ​ oracle 数据块是数据库中最小的逻辑存储单元，是数据库执行输入、输出操作的最小单位，由一个或多个操作系统块构成。在oracle 11g 数据库中，数据块分为 标准块和非标准块两种，其中标准块由数据库初始化参数 DB_BLOCK_SIZE 设置，其大小不可更改。oracle 数据库的默认数据缓冲区就是标准数据块构成的。 3.3 数据库：块 3.4 数据库实例ORACLE 内存结构和后台进程被成为数据库的实例 (1)SGA：SystemGlobal Area是OracleInstance的基本组成部分，在实例启动时分配;系统全局域SGA主要由三部分构成：共享池、数据缓冲区、日志缓冲区。 (2)共享池：Shared Pool用于缓存最近被执行的SQL语句和最近被使用的数据定义，主要包括：Librarycache（共享SQL区）和Datadictionarycache（数据字典缓冲区）。 共享SQL区是存放用户SQL命令的区域，数据字典缓冲区存放数据库运行的动态信息。 (3)缓冲区高速缓存：DatabaseBufferCache用于缓存从数据文件中检索出来的数据块，可以大大提高查询和更新数据的性能。 (4)大型池：Large Pool是SGA中一个可选的内存区域，它只用于shared server环境。 (5)Java池：Java Pool为Java命令的语法分析提供服务。 (6)PGA：ProcessGlobal Area是为每个连接到Oracledatabase的用户进程保留的内存。 4.DDL【重点，实操】4.1 创建表1234create table student(sid number(10),sname varchar2(10)) tablespace tt; tablespace不是必须的，如果没有指定tablespace则使用登陆用户使用的表空间上！ 123456789-- 使用子查询创建表-- emp所有数据create table emp2 as select * from emp;--10号部门的emp数据create table emp3 as select * from emp where deptno=10;--emp表结构:只要我们as后面的查询没有数据即可，即where条件的结果为false,通常我们可能使用1=2create table emp4 as select * from emp where 1=2; 4.2 添加字段12--为student添加age字段 number(5)alter table emp2 add age number(2); 4.3 修改字段12345-- 修改age字段 number(10)alter table emp2 modify age number(10);-- 修改字段名称 age --&gt; age2alter table emp2 rename column age to age2; 4.4 删除字段12--删除student的age2字段alter table emp2 drop column age2; 4.5 清空表数据12--情况student表数据,truncate vs deletetruncate table emp3; 正常情况下删除数据，如果发现删除错了，则可以通过 rollback 回滚。如果使用了截断表，则表示所有的数据不可恢复了。所以速度很快 。 4.6 删除表12-- 删除student表drop table emp3; 4.7 重命名表12-- 重命名student --&gt;student2rename emp2 to emp4 5.事务事务提交：commit 事务回滚：rollback 设置保存点：savepoint a ​ 在 oracle 中每个连接都会产生一个 session,一个 session 对数据库的修改，不会立刻反映到数据库的真实数据上，是允许回滚的。只有当提交了，才变成持久数据了。 可能出现死锁的情况 原子性（Atomicity） 一致性（Consistency） 隔离性（Isolation ） 持久性（Durability ） 原子性和一致性的差别？ 原子性： ​ 只一个事务中，包含若干个数据操作，这些操作是一个整体，要么一起完成，要么一起不完成，不能只完成其中的一部。比如你去银行转帐，从一个账户转帐到另一个账户，这是一个完整的事务，包括两个操作，从你第一个账户读数， 增加到第二个账户，并减去第一个账户中的钱，如果这些操作有一个失败了，整个事务都必须还原成最开始的状态。 一致性： ​ 是指数据库从一个完整的状态跳到另一个完整的状态，是用于保护数据库的完整性的。比如你修改数据库的某个外键值，如果没有和相应的主键对应，就违反了数据库的一致性。另外，还有读一致性，如：你刚写入一个数到数据库中，但还没有提交，这时候有人要读这个数，就涉及完整性问题，要保证读取的数据在整个数据库中是处于和其他数据一致的一个状态。 练习12345678-- 1.scott 下面创建一个表【emp1、empno number(10)、ename varchar2(50)】-- 2.添加一个字段【sal number(10,2)】-- 3.修改字段 【ename varchar(100)】-- 4.删除字段 【sal】-- 5.把表 emp1 改成 emp2-- 6.删除表 emp2-- 7.创建一个和 emp 结构一样的表，并同时插入工资大于 1000 的数据-- 8.清空表数据（用 truncate) 6.DML(改变数据结构）6.1 insert 语句表间数据拷贝 12-- 向dept1中插入dept表的数据insert into dept (deptno,dname,loc) values(50,'研发部','南京') 6.2 update 语句将编号为 7779 用户的工作换成编号为 7566 的雇员的工作和所属上级。 12update dept set dname='测试部',loc='帝都' where deptno=50--注意：若不加条件，则全部数据都会变更，所以我们的修改都是带条件的 6.3 delete 语句123456789101112--从emp2表中删除empno&gt;7369的员工delete from dept where deptno=50;--删除所有员工delete from emp4; --不用，即便我们需要清空数据，我们通常使用truncate--truncate vs delete？--基础面试题1.效率而言，truncate高于delete，truncate过程大体如下：先drop掉某个表，然后在创建一个空结构；而delete逐条删除数据2.跟事务相关：delete，可以rollback 回滚。如果使用了截断表，则表示所有的数据不可恢复了。所以速度很快 。--实际中，我们连delete都不怎么用？--实际中，我们通过设置一个标记字段，通过改变标记字段的值，来标识该条数据是否被删除。即实际删除做的是update操作 7.练习123456-- 1.往 emp 表中插入 empno,ename,sal 数据（111,'1',1000)(222,'2',2000)-- 2.把 empno=111 的员工 comm 改成 100-- 3.往 dept 表中插入 dept 表中 deptno=100 的数据-- 4.删除 empno=111 的数据-- 5.为所有人长工资，标准是： 10 部门长 10%； 20 部门长 15%； 30 部门长 20%其他部门长18%（要求用 DECODE 函数）-- 6.根据工作年限长工资，标准是：为公司工作了几个月就长几个百分点。 8.约束（完整性）​ http://blog.itpub.net/29785807/viewspace-1271431/ 约束就是指对插入数据的各种限制，例如：人员的姓名不能为空，人的年龄只能在 0~150 岁之间。约束可以对数据库中的数据进行保护。约束可以在建表的时候直接声明，也可以为已建好的表添加约束。 8.1 NOT NULL：非空约束12345--方式1：建表的同时创建约束create table t1(id number,name varchar2(20) constraint nn_t1_id not null); --方式2：建表后，添加约束 alter table t1 modify number constraint nn_t1_id not null; 8.2 PRIMARY KEY：主键约束不能重复，不能为空 1234create table t1(id number,qq number,constraint pk_t1_id primary key(id)); create table t1(id number primary key,qq number); alter table t1 add constraint pk_t1_id primary key(id); 8.3 UNIQUE：唯一约束，值不能重复（空值除外）1234方法一： SQL&gt; create table t1(id number,qq number,constraint un_t1_qq unique(qq)); 方法二： SQL&gt; alter table t1 add constraint un_t1_qq unique(qq); 8.4 CHECK：条件约束，插入的数据必须满足某些条件1234方法一： SQL&gt; create table t3(id number,sal number,constraint ck_t3_sal check(sal between 5000 and 50000)); 方法二： SQL&gt; alter table t3 add constraint ck_t3_sal check(sal&gt;5000); 8.5 Foreign Key：外键1234方法一： SQL&gt; create table t2(id number,cc number,constraint fk_t2_id foreign key(id) references t1(id)); 方法二： SQL&gt; alter table t1 add constraint pk_t2_id foreign key(id) references t1(id); 8.6 级联删除在建立外键的时候必须指定级联删除（ON DELETE CASCADE）。 8.7 使用 alter 命令为表添加约束8.8 删除约束123当删除特定表的主键约束时，如果该表具有相关的从表，那么在删除主键约束时必须带有CASCAED选项 语法：ALTER TABLE table_name DROP CONSTRAINT constraint_name |PRIMARY KEY 8.9 启用约束1ALTER TABLE table_name ENABLE CONSTRAINT constraint_name; 8.10 禁用约束1234--禁止约束指使约束临时失效。当禁止了约束之后，约束规则将不再生效。在使用SQL*LOADER或INSERT装载数据之前，为了加快数据装载速度，应该首先禁止约束，然后装载数据。语法： ALTER TABLE table_name DISABLE CONSTRAINT constaint_name [CASCAED];--CASCAED用于指定级联禁止从表的外部键 9.练习123456789101112131415161718-- 1.创建一张表 student-- id number-- name varchar2(10)-- age number(10)-- tel varchar2（10）-- 给 id 字段添加主键约束-- 给 name 字段添加非空约束-- 给 age 字段添加 check 约束（age 必须大于 18 岁)-- 给 tel 添加唯一 非空 约束-- 2.创建一张学员兴趣爱好表 hobby-- id number(10)-- hobby_namevarchar2(10)-- sidnumber --学生 id-- 给 sid 字段添加外键约束，并且要带级联删除-- 3.删除掉 student 表中 tel 字段的唯一约束（先写出查看该表约束的 sql)-- 4.手动添加 student 表中 tel 字段的唯一约束（约束名为： MY_CONSTRAINT_1)-- 5.禁用约束 MY_CONSTRAINT_1-- 6.启用约束 MY_CONSTRAINT_1 10.视图*视图：是一个封装了各种复杂查询的语句，就称为视图。 * 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/* 视图 ***** 1.什么是视图？ ①视图是一种虚表 ②视图建立在已有表的基础上，视图赖以建立的这些表称为基表 ③向视图中提供数据内容的语句为select语句，可以将视图理解为存储起来的select语句 ④视图是向用户提供基表数据的另一种表现形式 ⑤视图没有存储真正的数据，真正的数据还是存储在基表中 ⑥开发人员虽然操作的是视图，但最终视图还会转为操作基表 ⑦一个基表可以有0个或多个视图 2.什么时候使用视图？ ①如果不想让用户看到所有数据（字段、记录），只想让用户看到某些数据的时候，此时可以使用视图 ②当需要简化sql查询语句的编写时，可以使用视图，但不提高查询效率 3.视图应用领域 银行、电信、金融、证券军事等不便让用户知道所有数据的项目中 4.视图的作用 ①限制数据访问，隐藏数据的安全性 ②简化复杂查询 ③提供数据的相互独立 ④同样的数据，可以有不同的显示方式 ⑤经常可以用来做报表 5.视图常见问题 删除视图中的【某条】记录会影响基表吗？会影响基表 将【整个】视图删除，会影响表吗？不会影响基表 删除视图，会进入回收站吗？不会进入回收站 删除基表会影响视图吗？会影响视图 闪回基表后,视图有影响吗？视图又可以正常工作了 将emp表丢入回收站，drop table 表名 drop table emp; 从回收站将emp表闪回，flashback table 表名 to before drop flashback table emp to before drop; 查询回收站，show recyclebin show recyclebin; 清空回收站，purge recyclebin purge recyclebin; 6.视图和表的区别 1.视图是已经编译好了的sql，表不是 2.视图没有实际的物理存储记录，表有 3.视图是逻辑概念，表可以进行修改 5.表是内模式，视图是外模式 6.视图是我们查看表的方法，视图不让用户接触数据表，用户也就不知道表结构 7.表属于全局模式中的表，是实表，视图属于局部模式的表，是虚表。 8.视图建立、删除只影响视图本身，不影响表 PS：可以通过视图修改表的数据，单不建议使用 */--1.基于emp表所有列，创建视图emp_view_1，create view 视图名 as select对一张或多张基表的查询--默认情况下，普通用户无权创建视图，得让sysdba为你分配creare view的权限 --以sysdba身份，授权scott用户create view权限先使用scott账户连接，然后切换账户SQL&gt; conn system/as sysdba;输入口令: ****已连接。SQL&gt; show user;USER 为 \"SYS\"SQL&gt; sqlplus登录：用户名:system 密码:orclgrant create view to scott;--以sysdba身份，撤销scott用户create view权限revoke create view from scott;--2.基于emp表指定列，创建视图emp_view_2，该视图包含编号/姓名/工资/年薪/年收入（查询中使用列别名）--3.基于emp表指定列，创建视图emp_view_3(a,b,c,d,e)，包含编号/姓名/工资/年薪/年收入（视图中使用列名）--查询emp_view_3创建视图的结构--4.修改emp_view_3(id,name,salary,annual,income)视图，create or replace view 视图名 as 子查询--5.创建视图emp_view_4，视图中包含各部门的最低工资，最高工资，平均工资--6.创建视图emp_view_5，视图中包含员工编号，姓名，工资，部门名，工资等级--7.删除视图emp_view_1中的7788号员工的记录，使用delete操作，会影响基表吗？--8.修改emp_view_1为只读视图【with read only】，再执行上述delete操作，还行吗？--9.分页sql视图--员工名字、员工所属部门--报表 11.索引select * from user_indexes 查询现有的索引select * from user_ind_columns 可获知索引建立在那些字段上 11.1 什么是索引 一种用于提升查询效率的数据库对象； 通过快速定位数据的方法，减少磁盘的I/O； 索引信息与表独立存放； Oracle数据库自动使用和维护索引； 11.2 索引的分类 唯一索引 非唯一索引 11.3 创建索引的两种方式 手动创建：用户可以在其他列上创建唯一索引，以加速查询； 自动创建：在定义主键或唯一约束时，系统会自动在相应的字段上添加唯一索引； 11.4 索引优缺点建立索引的优点1.大大加快数据的检索速度; 2.创建唯一性索引，保证数据库表中每一行数据的唯一性; 3.加速表和表之间的连接; 4.在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。 索引的缺点 1.索引需要占物理空间。 2.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。 11.5 创建索引的原则创建索引：创建索引一般有以下两个目的：维护被索引列的唯一性和提供快速访问表中数据的策略。 –在 select 操作占大部分的表上创建索引； –在 where 子句中出现最频繁的列上创建索引； –在选择性高的列上创建索引（补充索引选择性，最高是 1， eg： primary key） –复合索引的主列应该是最有选择性的和 where 限定条件最常用的列，并以此类推第二列……。 –小于 5M 的表，最好不要使用索引来查询，表越小，越适合用全表扫描。 11.6 使用索引的原则–查询结果是所有数据行的 5%以下时，使用 index 查询效果最好； –where 条件中经常用到表的多列时，使用复合索引效果会好于几个单列索引。因为当 sql语句所查询的列，全部都出现在复合索引中时，此时由于 Oracle 只需要查询索引块即可获得所有数据，当然比使用多个单列索引要快得多； –索引利于 select，但对经常 insert， delte 尤其 update 的表，会降低效率。 eg：试比较下面两条 SQL 语句(emp 表的 deptno 列上建有 ununique index)： 123456语句 A： SELECT dname, deptno FROM dept WHERE deptno NOT IN (SELECT deptno FROM emp);语句 B： SELECT dname, deptno FROM dept WHERE NOT EXISTS (SELECT deptno FROM emp WHERE dept.deptno = emp.deptno); ​ 这两条查询语句实现的结果是相同的，但是执行语句 A 的时候， ORACLE 会对整个 emp 表进行扫描，没有使用建立在 emp 表上的 deptno 索引，执行语句 B 的时候，由于在子查询中使用了联合查询， ORACLE 只是对 emp 表进行的部分数据扫描，并利用了 deptno 列的索引，所以语句 B 的效率要比语句 A 的效率高。 –where 子句中的这个字段，必须是复合索引的第一个字段； eg：一个索引是按 f1, f2, f3 的次序建立的，若 where 子句是 f2 = : var2, 则因为 f2 不是索引的第 1 个字段，无法使用该索引。 —- where 子句中的这个字段，不应该参与任何形式的计算：任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。 —-应尽量熟悉各种操作符对 Oracle 是否使用索引的影响：以下这些操作会显式（ explicitly）地阻止 Oracle 使用索引： is null ; is not null ; not in; !=; like ;numeric_col+0;date_col+0; char_col||’ ‘; to_char; to_number， to_date 等。 Eg：Select jobid from mytabs where isReq=’0’ and to_date (updatedate) &gt;= to_Date ( ‘2001-7-18’,’YYYY-MM-DD’)； –updatedate 列的索引也不会生效。 11.7 创建索引12create index abc on student(sid,sname);create index abc1 on student(sname,sid); 这两种索引方式是不一样的； 索引 abc 对 Select * from student where sid=1; 这样的查询语句更有效； 索引 abc1 对 Select * from student where sname=‟louis‟; 这样的查询语句更有效； 因此建立索引的时候，字段的组合顺序是非常重要的。一般情况下，需要经常访问的字段放在组合字段的前面 ； 11.8 索引的存储​ 索引和表都是独立存在的。在为索引指定表空间的时候，不要将被索引的表和索引指向同一个表空间，这样可以避免产生 IO 冲突。使 Oracle 能够并行访问存放在不同硬盘中的索引数据和表数据，更好的提高查询速度。 11.9 删除索引1DROP INDEX idx_emp_ename_ning 11.10 索引类型B 树索引（B-Tree Index） 创建索引的默认类型，结构是一颗树，采用的是平衡 B 树算法： 右子树节点的键值大于等于父节点的键值 左子树节点的键值小于等于父节点的键值 比如有数据:100,101,102,103,104,105,106 位图索引(BitMap Index) ​ 如果表中的某些字段取值范围比较小，比如职员性别、分数列 ABC 级等。只有两个值。这样的字段如果建 B 树索引没有意义，不能提高检索速度。这时我们推荐用位图索引Create BitMap Index student on(sex); 11.11 管理索引1） 先插入数据后创建索引向表中插入大量数据之前最好不要先创建索引，因为如果先建立索引。那么在插入每行数据的时候都要更改索引。这样会大大降低插入数据的速度。 2） 设置合理的索引列顺序 3） 限制每个表索引的数量 4） 删除不必要的索引 5） 为每个索引指定表空间 6） 经常做 insert， delete 尤其是 update 的表最好定期 exp/imp 表数据，整理数据，降低碎 片（缺点：要停应用，以保持数据一致性，不实用）；有索引的最好定期 rebuild 索引（rebuild期间只允许表的 select 操作，可在数据库较空闲时间提交），以降低索引碎片，提高效率 11.12 索引问题1： 针对一个表的查询语句能否会用到两个索引? 2：如果能用到，那么其实现原理是怎样的？ 3：效率如何？其代价如何，比如额外开销等。 回答： 1.一个表的查询语句可以同时用到两个索引。如下图： 2.索引是以独立于表存在的一种数据库对象，它是对基表的一种排序（默认是 B 树索引就是二叉树的排序方式），比如：t 表(x,y,z) ,在 x,y,z 上分别都建立了索引(index1,index2,index3)，那在查询 select * from t where x=1 and y=2;的时候，会分别用到 index1,index2。原理是先到 index1 索引表中查到符合 x=1 条件的记录，然后到 index2 索引表中查到 y=2 条件的记录。 3.这样的查询效率，肯定是大于没有索引情况的全表扫描（table access full)，但是有两个问题。 问题一：建立索引将占用额外的数据库空间，更重要的是增删改操作的时候，索引的排序也必须改变，加大的维护的成本 问题二：如果经常查询 x=?和 y=?，那推荐使用组合 index(x,y)，这种情况下组合索引的效率是远高于两个单独的索引的。 同时在用组合索引的时候，大家一定要注意一个细节：建立组合索引 index(x,y,z)的时候，那在查询条中出现 x,xy,xyz都是可以用到该组合索引，但是 y,yz,z 是不能用到该索引的。关于这段话的原文如下： 1234567A leading portion of an index is a set of one or more columns that were specified first and consecutively in the list of columns in the CREATE INDEX statement that created the index. Consider this CREATE INDEX statement:CREATE INDEX comp_ind ON table1(x, y, z);x, xy, and xyz combinations of columns are leading portions of the indexyz, y, and z combinations of columns are not leading portions of the index 12. SQL 优化【面试】​ SQL 优化的实质就是在结果正确的前提下，用优化器可以识别的语句， 充份利用索引，执行过程中访问尽量少的数据块，减少表扫描的 I/O 次数，尽量避免全表扫描和其他额外开销。 ​ oracle 数据库常用的两种优化器： RBO（rule-based-optimizer）和 CBO(cost-based-optimizer)。目前更多地采用 CBO(cost-based-optimizer)基于开销的优化器。在 CBO 方式下， Oracle 会根据表及索引的状态信息来选择计划；RBO 方式下， Oracle 会根据自己内部设置的一些 规则来决定选择计划，例如 oracle 会根据以下优先级来选择执行计划（越靠前， rank 越低，越快）。 12345678为什么要Oracle优化： 随着实际项目的启动，Oracle经过一段时间的运行，最初的Oracle设置，会与实际Oracle运行性能会有一些差异，这时我们就需要做一个优化调整。Oracle优化这个课题较大，可分为四大类： 》主机性能 》内存使用性能 》网络传输性能 》SQL语句执行性能【程序员】——针对sql语句 12.1、 尽量少用 IN 操作符​ 基本上所有的 IN 操作符都可以用 EXISTS 代替， 在选择 IN 或 EXIST 操作时，要根据主子表数据量大小来具体考虑 12.2、 尽量用 NOT EXISTS 或者外连接替代 NOT IN 操作符​ 因为 NOT IN 不能应用表的索引 12.3、 尽量不用“&lt;&gt;”或者“!=”操作符​ 不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 比如： a&lt;&gt;0改为 a&gt;0 or a&lt;0 12.4、 在设计表时， 把索引列设置为 NOT NULL​ 判断字段是否为空一般是不会应用索引的，因为 B 树索引是不索引空值的。 12.5、 尽量不用通配符“%”或者“_”作为查询字符串的第一个字符​ 当通配符“%”或者“_”作为查询字符串的第一个字符时，索引不会被使用。比如用 T 表中column1 LIKE ‘%5400%‘这个条件会产生全表扫描，如果改成 column1 ‘X5400%’ OR column1 like ‘B5400%‟ 则会利用 column1 的索引进行两个范围的查询，性能肯定大大提高。 12.6、 Where 子句中避免在索引列上使用计算​ 如果索引不是基于函数的，那么当在 where 子句中对索引列使用函数时，索引不再起作用。因此 where 子句中避免在索引列上使用计算。 比如： substr(no,1,4)=’5400’， 优化处理： no like ‘5400%’ trunc(hiredate)=trunc(sysdate) ， 优 化 处 理 ： hiredate &gt;=trunc(sysdate) and hiredate&lt;trunc(sysdate+1) 12.7、 用“&gt;=”替代“&gt;”​ 大于或小于操作符一般情况下是不用调整的，因为它有索引就会采用索引查找，但有的情况下可以对它进行优化，如一个表有 100 万记录，一个数值型字段 A， 30 万记录的 A=0， 30 万记录的 A=1， 39 万记录的 A=2， 1 万记录的 A=3。那么执行 A&gt;2 与A&gt;=3 的效果就有很大的区别了，因为 A&gt;2 时 ORACLE 会先找出为 2 的记录索引再进行比较，而 A&gt;=3 时 ORACLE 则直接找到=3 的记录索引。 12.8、 利用 SGA 共享池，避开 parse 阶段同一功能同一性能不同写法 SQL 的影响 如一个 SQL A 程序员写的为：select * from zl_yhjbqk B 程序员写的为：select * from dlyx.zl_yhjbqk（带表所有者的前缀） C 程序员写的为：select * from DLYX.ZLYHJBQK（大写表名） D 程序员写的为：Select * from DLYX.ZLYHJBQK（中间多了空格） ​ 以上四个 SQL 在 ORACLE 分析整理之后产生的结果及执行的时间是一样的，但是从ORACLE 共享内存 SGA 的原理，可以得出 ORACLE 对每个 SQL 都会对其进行一次分析，并且占用共享内存，如果将 SQL 的字符串及格式写得完全相同则 ORACLE 只会分析一次，共享内存也只会留下一次的分析结果，这不仅可以减少分析 SQL 的时间，而且可以减少共享内存重复的信息， ORACLE 也可以准确统计 SQL 的执行频率。 ​ 不同区域出现的相同的 Sql 语句要保证查询字符完全相同， 建议经常使用变量来代替常量，以尽量使用重复 sql 代码， 以利用 SGA 共享池， 避开 parse 阶段，防止相同的 Sql 语句被多次分析，提高执行速度。因此使用存储过程，是一种很有效的提高 share pool 共享率，跳过 parse 阶段，提高效率的办法。 12.9、 WHERE 后面的条件顺序要求WHERE 后面的条件， 表连接语句写在最前， 可以过滤掉最大数量记录的条件居后。 比如： Select * from zl_yhjbqk where dy_dj = ‘1KV 以下’ and xh_bz=1 Select * from zl_yhjbqk where xh_bz=1 and dy_dj = ‘1KV 以下’ ​ 以上两个 SQL 中 dy_dj（电压等级）及 xh_bz（销户标志）两个字段都没进行索引，所以执行的时候都是全表扫描，第一条SQL的dy_dj = ‘1KV以下’条件在记录集内比率为99%，而 xh_bz=1 的比率只为 0.5%，在进行第一条 SQL 的时候 99%条记录都进行 dy_dj 及 xh_bz的比较，而在进行第二条 SQL 的时候 0.5%条记录都进行 dy_dj 及 xh_bz 的比较，以此可以得出第二条 SQL 的 CPU 占用率明显比第一条低。 12.10、 使用表的别名，并将之作为每列的前缀​ 当在 Sql 语句中连接多个表时，使用表的别名，并将之作为每列的前缀。这样可以减少解析时间 12.11、 进行了显式或隐式的运算的字段不能进行索引比如： ss_df+20&gt;50，优化处理： ss_df&gt;30 ’X‘||hbs_bh&gt;’X5400021452‘，优化处理： hbs_bh&gt;’5400021542‘ sk_rq+5=sysdate，优化处理： sk_rq=sysdate-5 hbs_bh=5401002554，优化处理： hbs_bh=‟ 5401002554‟，注：此条件对 hbs_bh 进行隐式的 to_number 转换，因为 hbs_bh 字段是字符型。 12.12、 用 UNION ALL 代替 UNION​ UNION 是最常用的集操作，使多个记录集联结成为单个集，对返回的数据行有唯一性要求，所以 oracle 就需要进行 SORT UNIQUE 操作（与使用 distinct 时操作类似），如果结果集又比较大，则操作会比较慢； ​ UNION ALL 操作不排除重复记录行，所以会快很多，如果数据本身重复行存在可能性较小时，用 union all 会比用 union 效率高很多！ 12.13、其他操作尽量使用 packages： Packages 在第一次调用时能将整个包 load 进内存，对提高性能有帮助。 尽量使用 cached sequences 来生成 primary key ：提高主键生成速度和使用性能。 很好地利用空间：如用 VARCHAR2 数据类型代替 CHAR 等 使用 Sql 优化工具： sqlexpert； toad； explain-table； PL/SQL； OEM 12.14、 通过改变 oracle 的 SGA 的大小SGA：数据库的系统全局区。 SGA 主要由三部分构成：共享池、数据缓冲区、日志缓冲区 1、 共享池又由两部分构成：共享 SQL 区和数据字典缓冲区。共享 SQL 区专门存放用户 SQL 命令， oracle 使用最近最少使用等优先级算法来更新覆盖；数据字典缓冲区（library cache）存放数据库运行的动态信息。数据库运行一段时间后，DBA 需要查看这些内存区域的命中率以从数据库角度对数据库性能调优。通过执行下述语句查看： 1select (sum(pins - reloads)) / sum(pins) \"Lib Cache\" from v$librarycache; –查看共享 SQL 区的重用率，最好在 90％以上，否则需要增加共享池的大小。 1select (sum(gets - getmisses - usage - fixED)) / sum(gets) \"Row Cache\" from v$rowcache; –查看数据字典缓冲区的命中率，最好在 90％以上，否则需要增加共享池的大小。2、 数据缓冲区：存放 sql 运行结果抓取到的 data block； 1SELECT name, value FROM v$sysstat WHERE name IN ('db block gets', 'consistent gets','physical reads'); –查看数据库数据缓冲区的使用情况。查询出来的结果可以计算出来数据缓冲区的使用命中率＝1 - ( physical reads / (db block gets + consistent gets) )。命中率应该在 90％以上，否则需要增加数据缓冲区的大小。 3、 日志缓冲区：存放数据库运行生成的日志。 1select name,value from v$sysstat where name in ('redo entries','redo log space requests'); –查看日志缓冲区的使用情况。查询出的结果可以计算出日志缓冲区的申请失败率：申请失败率＝requests/entries，申请失败率应该接近于 0，否则说明日志缓冲区开设太小，需要增加 ORACLE 数据库的日志缓冲区 。 13.序列、同义词13.1 序列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 1.什么是序列【Sequence】 ***** ①类似于MySQL中的auto_increment自动增长机制，但Oracle中无auto_increment机制 *** ②是oracle提供的一个产生唯一数值型值的机制 *** ③通常用于表的主健值*** ④序列只能保证唯一，不能保证连续 声明：oracle中，只有rownum永远保持从1开始，且继续 ⑤序列值，可放于内存，取之较快 2.为什么要用序列 ①以前我们为主健设置值，需要人工设置值，容易出错 ②以前每张表的主健值，是独立的，不能共享 3.为什么oracle不直接用rownum做主健呢？ rownum=1这条记录不能永远唯一表示SMITH这个用户，但主键=1确可以永远唯一表示SMITH这个用户 4.语法 CREATE SEQUENCE sq_name --创建序列 [start with n] [increment by n][ maxvalue n|nomaxvalue][cycle|nocycle][cache n|nocache] ; sq_name.currval --当前序号 sq_name.nextval --下一个序号 DROP SEQUENCE sq_name; --删除序列 5.常见问题 删除表，会影响序列吗？你无法做insert操作 删除序列，会影响表吗？表真正亡，序列亡*/--1.为emp表的empno字段，创建序列emp_empno_seq，create sequence 序列名--2.删除序列emp_empno_seq，drop sequence 序列名--3.查询emp_empno_seq序列的当前值currval和下一个值nextval，第一次使用序列时，必须选用：序列名.nextval--4.使用序列，向emp表插入记录，empno字段使用序列值--5.修改emp_empno_seq序列的increment by属性为20，默认start with是1，alter sequence 序列名--6.修改emp_empno_seq序列的的increment by属性为5--7.修改emp_empno_seq序列的start with属性，行吗:注意已经启动的序列改不了--8.有了序列后，还能为主健手工设置值吗？可以设置 13.2 同义词1,.什么是同义词 同义词（Synonym）是数据库对象的一个别名，Oracle 可以为表、视图、序列、过程、函数、程序包等指定一个别名。 2.作用 ①缩短对象名字的长度 ②方便访问其它用户的对象 ③为用户简化sql语句 3.同义词有两种类型： 1、私有同义词：拥有 CREATE SYNONYM 权限的用户（包括非管理员用户）即可创建私有同义词，创建的私有同义词只能由当前用户使用。 2、公有同义词：系统管理员可以创建公有同义词，公有同义词可以被所有用户访问。 语法结构 1create [or replace] [public] synonym synonym_name for [schema.]object_name 梨子：创建一个用户 xiaohei，该用户拥有 connect 角色和 resource角色。为 scott用户的 emp表创建同义词，并通过同义词访问该 emp表。 4.如何使用 123456789101112131415--1.创建与salgrade表对应的同义词，create synonym 同义词 for 表名/视图/其它对象create synonym e for salgrade;create synonym ev5 for emp_view_5;--以sys身份授予scott普通用户create synonym权限grant create synonym to scott;--以sys身份从scott普通用户撤销create synonym权限revoke create synonym from scott;--2.使用同义词操作salgrade表select * from s;--3.删除同义词drop synonym ev5; 5.常见问题 ①删除同义词，会影响基表吗？ 不会影响基表 ②删除基表，会影响同义词吗？ 会影响同义词 14.练习1234567891011121314-- 1:创建一个包含 1982 年 3 月 31 日以后入职的所有雇员的视图-- 2：创建一个包含佣金高于其薪金的雇员视图-- 3：创建一个包含所有雇员的雇员编号、雇员名称、部门名称和薪金的视图-- 4：创建一个有手下的雇员的视图，包括雇员编号，雇员名称-- 5：创建一个包含各种工作的薪金总和的视图-- 8： 创建一个序列，从 50 开始，每次增加 10-- 9：用上面的序列给 dept 表加一条数据-- 9：为 emp 表创建一个同义词 emp1-- 10：在上面创建的同义词中插入值，并观察对基表的影响-- 11：在 emp 表的 empno 字段上创建一个索引，并检查是否可以创建-- 12：在 emp 表的 sal 上创建一个索引-- 13：列出您所创建的全部视图、同义词、序列和索引。-- 14：删除你所创建的任何视图的基表，然后尝试查询视图，并观察查询的输出情况-- 15：删除您创建的所有视图、同义词、序列和索引。","link":"/2019/10/11/4-Oralce/"}],"tags":[{"name":"network","slug":"network","link":"/tags/network/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"oracle练习","slug":"oracle练习","link":"/tags/oracle练习/"}],"categories":[{"name":"oracle","slug":"oracle","link":"/categories/oracle/"}]}